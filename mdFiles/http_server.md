# http 모듈로 서버 만들기

- node는 서버가 아니다 -> js 실행기일 뿐, 서버 실행 코드를 작동시켜줄 뿐.
- 서버와 클라이언트는 요청과 응답을 http 프로토콜(규약)에 맞게 주고받음
- 코드가 바뀌면 서버는 재시작 되어야 함 (지켜보고 있다가 특정 조건에 재시작하게끔 실행코드를 짜둘 수는 있다)

1. http 요청에 응답하는 노드 서버
    - `createServer` 로 요청 이벤트에 대기
    - 콜백함수로 객체로 정보를 받음 ->`req`: 요청에 관한 정보,  `res`: 응답에 관한 정보 
    - res 객체의 메서드
        - `res.writeHead`: (Network Response Headers)응답에 대한 정보를 기록-> (첫번째 인수)http 상태코드, (두번째 인수)응답에 대한 정보로 이루어짐
        - `res.write`: 클라이언트로 보낼 데이터, 문자열/버퍼 등을 보낼 수 있음
        - `res.end`: 응답을 종료하는 메서드, 인수가 있다면 클라이언트로 보내고 응답을 종료함 -> `return`을 붙여야 함수가 종료됨

2. `fs`로 HTML 읽어 제공하기
    - `fs.readFile`로 파일 읽기
    - `async` 이용해서 `try-catch`문으로 에러 처리하기
    
3. REST API 서버 만들기
    - 서버에 요청을 보낼 때는 주소를 통해 요청의 내용을 표현. 
    REST에서는 주소 외에도 HTTP 요청 메서드라는 것을 사용 (GET, POST, PATCH...)
    - REST: REpresentational State Transfer -> 서버의 자원을 정의하고 자원에 대한 주소를 지정하는 방법
    - 주소 하나가 요청 메서드를 여러 개 가질 수 있음
    
-------
[코드]()

- require로 http 모듈을 불러옴
- http 모듈의 `createServer` 함수로 서버 생성
- `.listen` 함수는 서버를 시작하게 하고, 클라이언트의 요청에 대기함 (8082 포트에서 대기중)
- createServer 함수에 비동기 함수 넘김. try-catch 문 사용
    - `GET(가져옴)`
        - 웹 브라우저 주소창에 URL을 입력하는 경우
        - 링크를 클릭하는 경우
        - 입력폼의 메소드 속성값이 get인 경우
    - `POST(게시)`, `PUT(집어넣음)` : 코드의 흐름을 기억할 것
        - `body`를 만든 후, 요청을 stream 형식으로 받음(코드 확인하기)
        - `req.on('data')`, `req.on('end')` 사용 -> 데이터를 꺼내기 위한 작업

    (POST의 GET의 문제점 해결)
        - URL에 데이터가 포함되지 않아 외부에 노출되지 않음
        - 바이너리, 대용량 데이터 전송 가능

    - `PATCH(부분 수정)`
    - `DELETE(삭제)`
--------
요청과 응답은 모두 헤더와 본문을 가짐. 헤더는 요청/응답에 대한 정보를 가지고, 본문은 서버와 클라이언트 간에 주고받을 실제 데이터를 담아둠

-> 개발자 도구 Network 탭에서 확인 가능

- `General`: 공통된 헤더
- `Request Headers`: 요청의 헤더
- `Response Headers`: 응답의 헤더 
- `Request Payload`: 요청의 본문
- `Preview`나 `Response` 탭: 응답의 본문

4. 쿠키: 키-값의 쌍
    - 매 요청마다 서버에 동봉해서 보냄, 서버는 쿠키를 읽어 누가 요청을 보냈는지 파악
    - 쿠키 넣는 것을 구현
        - `writeHead`: 요청 헤더에 입력하는 메서드
        - `Set-Cookie`: 브라우저에게 쿠키를 설정(저장)하라고 명령
        - `키=값` 쌍으로 설정
    - 쿠키는 요청의 헤더(Cookie)에 담겨 전송됨, 브라우저는 응답의 헤더(Set-Cookie)에 따라 쿠키를 저장
    - 쿠키는 문자열 형식으로 존재, 쿠키 간에는 세미콜론으로 구분
    - 쿠키 만료 기한 저장 가능(Expires=날짜)
    - 쿠키가 전송될 도메인, URL 특정할 수 있음
    - 쿠키 조작을 방지하기 위해 `HttpOnly`를 설정해 js 에서 쿠키에 접근할 수 없게 함

```JS
http.createServer((req,res)=>{
    res.writeHead(200,{'Set-Cookie': 'cookie=test'});
    res.end('Hello Cookie');
})
    .listen(8083,()=>{
        //서버 대기중
    })
```

5. 세션
쿠키의 정보는 노출되고 수정되는 위험이 있어서, 
이를 해결하는 방법이, 서버에 `세션 객체`를 생성한 후, 중요한 정보에 접속할 수 있는 세션 키만 브라우저에 보내는 방법이다.

서버에 사용자 정보를 저장하고 클라이언트와는 세션 아이디로만 소통하는데, 꼭 쿠키를 사용해서 주고 받지 않아도 되지만,
많은 웹사이트들이 쿠키를 사용한다. 

-> 세션을 위해 사용하는 쿠키를 `세션 쿠키`라고 함

- 실제 서버에서는 세션을 변수에 저장하지 않고, `Redis`나 `Memcached`와 같은 데이터베이스에 넣어둠
- 서비스를 새로만들 때마다 쿠키와 세션을 직접 구현할 수도 없고, 보안을 위해 검증된 코드를 사용하는 것이 좋음
(다음장에서 express-session을 사용해보자)

6. https, http2

`https`:  웹 서버에 SSL 암호화를 추가하는 모듈
-> GET이나 POST 요청을 할 때 오가는 데이터를 암호화해서 중간에서 탈취한 내용을 확인할 수 없게 함
- https 인증서는 인증 기관에서 구입해야하고, Let's Encrypt 같은 기관에서 무료로 발급 가능
- createServer 메서드가 인수를 두개 받음. (`인증서에 관련된 옵션 객체`, `서버 로직`)
- 인증서를 구입하면 pem, crt, key 확장자를 가진 파일들이 제공되는데, 이 파일을 `fs.readFileSync` 메서드로 읽어서 cert,key,ca 옵션에 알맞게 넣음.
- 실제 서버에서는 `443 포트`를 사용

`http2`: SSL 암호화와 더불어 최신 HTTP 프로토콜은 http/2를 사용하는 모듈
- 요청 및 응답 방식이 기존 http 보다 개선됨
- https 보안도 적용하기 때문에, 속도와 보안 면에서 좋음
- 실무에서 배포시 기존 https 코드에서, https 모듈을 `http2`로, createServer 메서드를 `createSecureServer` 로 변경

7. cluster



----
# 포트 

- localhost : 현재 사용하는 컴퓨터의 내부 주소
- 포트 : 서버 내 프로세스를 구분하는 번호 -> 서버는 프로세스에 포트를 다르게 할당해 들어오는 요청을 구분함
    - 유명한 포트 번호: 21(FTP), 80(HTTP), 443(HTTPS), 3306(MYSQL)
- 80번 포트를 사용하면 주소에서 포트를 생략할 수 있음 -> 배포시 사용
- 이론상으로 한번에 여러개의 포트를 열어, 여러개의 서버를 실행할 수 있음
